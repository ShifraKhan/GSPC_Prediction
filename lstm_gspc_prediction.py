# -*- coding: utf-8 -*-
"""LSTM GSPC Prediction

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1NXSZmp9lJMGM0P5Z28rtwg53lsOJ0fmw
"""

import keras
from keras.layers import Dense
from keras.layers import LSTM
from keras.layers import Dropout
import pandas as pd 
import pandas_datareader.data as web
import datetime
import numpy as np 
from matplotlib import style

import warnings
warnings.filterwarnings('ignore')

style.use('ggplot')

# get training data
start = datetime.datetime(2014,1,1)
end = datetime.datetime(2018,12,30)
df = web.DataReader("^GSPC", 'yahoo', start, end) 

# get testing data 
start = datetime.datetime(2019,1,1)
end = datetime.date.today()
test_df = web.DataReader("^GSPC", 'yahoo', start, end)

# sorting
df = df.sort_values('Date')
test_df = test_df.sort_values('Date')
df.reset_index(inplace=True)
df.set_index("Date", inplace=True)
test_df.reset_index(inplace=True)
test_df.set_index("Date", inplace=True)

df.tail()

# Commented out IPython magic to ensure Python compatibility.
# Vizualize training
import matplotlib.pyplot as plt
# %matplotlib inline

plt.figure(figsize = (12,6))
plt.plot(df["Adj Close"])
plt.xlabel('Date',fontsize=15)
plt.ylabel('Adjusted Close Price',fontsize=15)
plt.show()

# Rolling mean
close_px = df['Adj Close']
mavg = close_px.rolling(window=100).mean()

plt.figure(figsize = (12,6))
close_px.plot(label='^GSPC')
mavg.plot(label='mavg')
plt.xlabel('Date')
plt.ylabel('Price')
plt.legend()

import matplotlib.dates as mdates

dates_df = df.copy()
dates_df = dates_df.reset_index()

# Store original data for plotting
org_dates = dates_df['Date']

dates_df['Date'] = dates_df['Date'].map(mdates.date2num)

dates_df.tail()

# Use sklearn support vector regression to predicit
from sklearn.svm import SVR

dates = dates_df['Date'].as_matrix()
prices = df['Adj Close'].as_matrix()

#Convert to 1d Vector
dates = np.reshape(dates, (len(dates), 1))
prices = np.reshape(prices, (len(prices), 1))

svr_rbf = SVR(kernel= 'rbf', C= 1e3, gamma= 0.1)
svr_rbf.fit(dates, prices)

plt.figure(figsize = (12,6))
plt.plot(dates, prices, color= 'black', label= 'Data')
plt.plot(org_dates, svr_rbf.predict(dates), color= 'red', label= 'RBF model') 
plt.xlabel('Date')
plt.ylabel('Price')
plt.legend()
plt.show()

# Create train set (adj close prices data)
train_data = df.loc[:,'Adj Close'].as_matrix()
print(train_data.shape)

# Normalization
from sklearn.preprocessing import MinMaxScaler

scaler = MinMaxScaler()
train_data = train_data.reshape(-1,1)

scaler.fit(train_data)
train_data = scaler.transform(train_data)

'''Function to create a dataset to feed into an LSTM'''
def create_dataset(dataset, look_back):
    dataX, dataY = [], []
    for i in range(len(dataset)-look_back):
        a = dataset[i:(i + look_back), 0]
        dataX.append(a)
        dataY.append(dataset[i + look_back, 0])
    return np.array(dataX), np.array(dataY)

# Create training data:
time_steps = 36
X_train, y_train = create_dataset(train_data, time_steps)

# Reshape 
X_train = np.reshape(X_train, (X_train.shape[0], 36, 1))

print(X_train.shape)

print('X_train:')
print(str(scaler.inverse_transform(X_train[0])))
print("\n")
print('y_train: ' + str(scaler.inverse_transform(y_train[0].reshape(-1,1)))+'\n')

model = keras.Sequential()

model.add(LSTM(units = 100, return_sequences = True, input_shape = (X_train.shape[1], 1)))
model.add(Dropout(0.2))

model.add(LSTM(units = 100))
model.add(Dropout(0.2))

# Output layer
model.add(Dense(units = 1))

# Compile
model.compile(optimizer = 'adam', loss = 'mean_squared_error')

# Fitting the model to training set
history = model.fit(X_train, y_train, epochs = 20, batch_size = 10, validation_split=.30)

# Plot training & validation loss 
plt.plot(history.history['loss'])
plt.plot(history.history['val_loss'])
plt.title('Model loss')
plt.ylabel('Loss')
plt.xlabel('Epoch')
plt.legend(['Train', 'Test'], loc='upper left')
plt.show()

# Get stock prices
test_data = test_df['Adj Close'].values
test_data = test_data.reshape(-1,1)
test_data = scaler.transform(test_data)

# Create the data to test our model on:
time_steps = 36
X_test, y_test = create_dataset(test_data, time_steps)

# store the original vals for plotting the predictions 
y_test = y_test.reshape(-1,1)
org_y = scaler.inverse_transform(y_test)

# reshape it [samples, time steps, features]
X_test = np.reshape(X_test, (X_test.shape[0], 36, 1))

# Predict the prices with the model
predicted_y = model.predict(X_test)
predicted_y = scaler.inverse_transform(predicted_y)

plt.plot(org_y, color = 'black', label = 'Real Price')
plt.plot(predicted_y, color = 'blue', label = 'Predicted  Price')
plt.title('Stock Price Prediction')
plt.xlabel('Time')
plt.ylabel('Stock Price')
plt.legend()
plt.show()